\documentclass[12pt, a4paper]{article}

\usepackage[T2A]{fontenc}		%cyrillic output
\usepackage[utf8]{inputenc}		%cyrillic output
\usepackage[english, russian]{babel}	%word wrap
\usepackage{amssymb, amsfonts, amsmath}	%math symbols
\usepackage{mathtext}			%text in formulas
\usepackage{geometry}			%paper format attributes
\usepackage{fancyhdr}			%header
\usepackage{graphicx}			%input pictures
\usepackage{tikz}				%draw pictures
\usepackage{pgfplots}			%draw graphics
\usetikzlibrary{patterns}		%draw pictures: fill
\usetikzlibrary{calc}			%draw pictures: coordinate calc
% \usetikzlibrary{external}		%draw pictures: cache pitcures
% \tikzexternalize				%cache pictures
\usepackage{listings}			%code
\usepackage{enumitem}			%noindent

\geometry{left=1cm, right=1cm, top=2cm, bottom=1cm, headheight=28pt}
\setlist[enumerate]{leftmargin=*}	%remove enumarate indenttion
\sloppy							%correct overfull
\newcommand{\subsectionbreak}{\clearpage} %new section

\newcommand{\head}[4]
{
	\pagestyle{fancy}
	\fancyhf{}
	\lhead{#3 \\ #2}
	\rhead{#1}
	
	\begin{center}
	\begin{large}
	#1 \\
	\textit{#2}\\
	\end{large}
	\end{center}
}

\lstset{language=C++}
\lstset{basicstyle=\footnotesize\ttfamily} 
\lstset{keywordstyle=\color{blue}}
\lstset{frame=single}
\lstset{numbers=left}

\sloppy

\newcommand{\problemauthor}[1]{
\begin{flushright}
\textit{Автор: #1}
\end{flushright}
}

\newcommand{\problemofferer}[1]{
\begin{flushright}
\textit{Предложил: #1}
\end{flushright}
}


\begin{document}

\head{Открытая олимпиада по программированию \\ Осенний тур 2018}{20 октября 2018}{Казахстанский филиал МГУ имени М.В.Ломоносова}{г.~Астана}


\subsection*{A. Archeologist’s find}

Ответ выводится в зависимости от расположения точки относительно осей.

Асимптотика по времени: $O(1)$.

\lstinputlisting{code/2018-10-A.cpp}

\newpage

\subsection*{B. Board rotating }

Обозначим $a_{i, j}$ --- исходную таблицу, $b_{i, j}$ --- итоговую таблицу. При повороте по часовой стрелке $b_{i, j} = a_{15 - j, i}$. При повороте против часовой стрелки $b_{i, j} = a_{j, 15 - i}$.

\lstinputlisting{code/2018-10-B.cpp}

Асимптотика по времени: $O(1)$.

\newpage

\subsection*{C. Counting pixels}

Пусть $A$ --- начало отрезка, $B$ --- конец отрезка; $a$ -- смещение по одной оси, $b$ --- по другой оси. Рассмотрим два случая: отрезок не проходит ни через один из углов пикселей и отрезок проходит через какой-либо угол.

В первом случае
\input{pictures/2018-10-C2}
Количество закрашенных пикселей будет 
$$a + b + 1$$
так как каждый сдвиг по любой из осей --- переход в новый закрашенный пиксель, и еще начальный пиксель.

Во втором случае каждый из узлов уменьшает ответ первого случая на 1 (так как переход происходит сразу по 2 осям). Посчитаем количество узлов. Выберем любой из узлов $C$, через который проходит отрезок. И перенесем параллельным переносом часть отрезка $AC$ и все сопутствующие ему пиксели так, чтобы $A$ совпало с $B$. 

\input{pictures/2018-10-C}
\input{pictures/2018-10-C1}


Получили классическую задачу: количество внутренних узлов на отрезке, которых начинается и заканчивается в узлах. Ответ: $d - 1$, где $d = \text{НОД}(a, b)$. Учитывая сам узел $C$, получим, что ответ $$a + b + 1 - d.$$ Наибольший общий делитель можно найти алгоритмом Евклида.

Осталось отметить, как отличать первый и второй случай. Во втором минимальный шаг от узла до узла будет равен $\left(\frac{a}{d} ; \frac{b}{d} \right)$. Двигаясь по данному направлению мы попадаем в центр пикселя, только если $k \frac{a}{d}$ и $k \frac{b}{d}$ будут полуцелыми. Ясно, что $k$ тогда само --- полуцелое число. Но тогда $\frac{a}{d}$ и $\frac{b}{d}$ не могут быть четными.

Асимптотика по времени: $O(\log \max(i_1, i_2, j_1, j_2))$.

\lstinputlisting{code/2018-10-C.cpp}
\newpage

\subsection*{D. Digits again}

Заметим, что в виде $\lambda_1^n + \lambda_2^n$ записываются решения линейного рекуррентного соотношения
$$ x_{n+2} - (\lambda_1 + \lambda_2) x_{n+1} + \lambda_1 \lambda_2 x_{n} = 0,$$
у которого характеристический многочлен имеет корни $\lambda_1$ и $\lambda_2$. 

Если обозначить:
$$x_n = \left(a+\sqrt{b} \right)^n + \left(a - \sqrt{b} \right)^n$$
то получим, что 
$$x_{n+2} - 2 a x_{n+1} + (a^2 - b) x_n = 0$$

Значит:
$$x_{n+1} = 2 a x_{n} + (b - a^2) x_{n-1}$$

Считать такую рекурренту наивным образом слишком долго. 

\textbf{Решение 1.} Воспользуемся матричной формой записи:
$$
\begin{pmatrix}
x_{n+1} \\
x_{n}
\end{pmatrix}
=
\begin{pmatrix}
2 a & b - a^2 \\
1 & 0 \\
\end{pmatrix}
\begin{pmatrix}
x_{n} \\
x_{n}-1
\end{pmatrix}
=
\begin{pmatrix}
2 a & b - a^2 \\
1 & 0 \\
\end{pmatrix}^{n}
\begin{pmatrix}
x_{1} \\
x_{0}
\end{pmatrix}
$$

Возвести матрицу в степень можно бинарным возведением. Стоит отметить, что все операции следует выполнять по модулю 1000, не забывая аккуратно работать с разностью остатков (чтобы не получать отрицательные числа). 

Асимптотика по времени: $O(\log n )$.

\textbf{Решение 2.} Заметим, что рекуррентное соотношение определяется двумя подряд идущими элементами. Так как мы смотрим рекуррентное соотношение по модулю 1000, то существует не более 1000000 различных пар остатков. Значит, если промоделировать $k > 1000000$ шагов, то там точно найдутся две одинаковые пары остатков. 

Найдем максимально $j < k$ такое, что $x_j = x_k$. Тогда $m = k - j$ будет периодом для последовательности $x_i$. Теперь, чтобы вывести ответ $x_n$ поступим так: 

$$
x_n = 
\begin{cases}
x_n, & n < k \\
x_{j + ((n - k) \bmod m)}, & n \geqslant k \\
\end{cases}
$$

Асимптотика по времени: $O(s^2)$, где $s$ --- модуль (1000).

\lstinputlisting{code/2018-10-D.cpp}

\newpage

\subsection*{E. Emirates}
По внешнем виду можно угадать график функции $$a x + \frac{b}{x},$$ где $a > 0$, $b > 0$. Коэффициенты подбираются из примеров:
$$f(x) = 2 x + \frac{12}{x}$$
\input{pictures/2018-10-E}

А еще день независимости ОАЭ это 2.12 =)

\lstinputlisting{code/2018-10-E.cpp}

\newpage

\subsection*{F. Finding battleships}

Запустим обход в глубину (dfs) на графе, соответствующем таблице (переходить можно на соседнюю по вертикали или горизонтали клетку) для каждой еще не посещенной клетки. При этом будет вычислить 5 параметров: $size$ --- количество клеток в компоненте связности, $i_{min}$, $i_{max}$ --- минимальная и максимальная строка, до которой дошел обход в данной компоненте, $j_{min}$, $j_{max}$ --- минимальный и максимальный столбец, до которого дошел обход в данной компоненте. Обозначим $height = i_{max} - i_{min} + 1$, $width = j_{max} - j_{min} + 1$. 
Область будет прямоугольной тогда, и только тогда, когда:
$$ height * width = size$$
Определить тип прямоугольника можно естественным образом.

Асимптотика по времени: $O(n \cdot m)$.

\lstinputlisting{code/2018-10-F.cpp}

\newpage

\subsection*{G. Geometrying}

Уравнение плоскости:
$$ \frac{x}{p} + \frac{y}{q} + \frac{z}{r} = 1$$

Точка лежит выше плоскости, если левая часть больше 1. Точка лежит ниже, если левая часть меньше 1. Данные условия можно проверить без перехода к вещественным числам:
$$ check(x, y, z) = x q r + y p r + x p q - p q r$$
Таким образом легко проверить, что отрезок строго пересекает плоскость, если
$$
\begin{cases}
check(x_1, y_1, z_1) < 0 \\
check(x_2, y_2, z_2) > 0 \\
\end{cases}
$$
Осталось посчитать сколько из 12 ребер куба строго пересекают плоскость и прибавить к ним количество вершин, которые лежат на плоскости $check(x, y, z) = 0$. 

Сгенерировать координаты вершин куба можно с помощью битовых операций. Проверить, какие из вершин образуют ребро можно с помощью условия, что расстояние (вдоль ребер) равно 1.

Асимптотика по времени: $O(1)$.

\lstinputlisting{code/2018-10-G.cpp}

\newpage

\subsection*{H. Highest and greatest only}

Обозначим $f(n, k)$ --- количество целых чисел от 1 до $n$, у которых все цифры меньше или равны $k$. Во-первых, найдем максимальное $m < n$, у которого все цифры не превосходят $k$. Это можно сделать двигаясь от старших разрядов к младшим пока цифра не больше $k$. Если встретилась цифра, больше $k$, то заменяем на $k$ эту цифру и все остальные цифры после неё (в сторону младших цифр). Можно сделать за $\log n$. Во-вторых, получаем ответ как результат перевода числа $m$ из $(k + 1)$-ичной системы счисления. Тоже можно сделать за $\log n$. Например, $n = 3251$ и $k = 3$. Найдем $m = 3233$. Сколько чисел меньше $3233$ и имеет цифры $0, 1, 2, 3$: 1, 2, 3, 10, 11, 12, 13, 20, 21, 22, 23, 30, 31, 32, 33, 100, ..., 3230, 3231, 3232, 3233. Если их сопоставить записи в системе счисления по основанию 4, то получим все натуральные числа до $3 \cdot 4^3 + 2 \cdot 4^2 + 3 \cdot 4^1 + 3 \cdot 4^0$.

Обозначим $g(n, k)$ --- количество целых чисел от 1 до $n$, у которых максимальная цифра в точности равна $k$. Тогда $g(n, k) = f(n, k) - f(n, k - 1)$. Ответ на задачу для чисел от 1 до $n$:
$$ s(n) = 1 \cdot g(n, 1) + 2 \cdot g(n, 2) + ... + 9 \cdot g(n, 9)$$

Ответ на задачу для чисел от $l$ до $r$:
$$ s(r) - s(l - 1).$$

Асимптотика по времени: $O(\log n)$.

\lstinputlisting{code/2018-10-H.cpp}

\newpage

\subsection*{I. Into the mountains}

Посчитаем $L_i$ --- длину наибольшей возрастающей подстроки, которая находится левее $i$-го элемента и заканчивается в $i$. Это можно сделать за линейный проход слева направо:
$$
L_i =
\begin{cases}
L_{i-1} + 1, & a_{i-1} < a_i \\
0, & a_{i-1} \geqslant a_i \\
\end{cases}
$$

Посчитаем $R_i$ --- длину наибольшей убывающей подстроки, которая находится правее $i$-го элемента и заканчивается в $i$. Это можно сделать за линейный проход справа налево:
$$
R_i =
\begin{cases}
R_{i+1} + 1, & a_{i} > a_{i + 1} \\
0, & a_{i} \leqslant a_{i + 1} \\
\end{cases}
$$

Полуширина горы с вершиной в точке $i$ определяется как $w_i = \min(L_i, R_i)$. Полная ширина горы с равна $2 w + 1$. Найдем максимальную ширину и выведем $i - w_i$, $i + w_i$.

\lstinputlisting{code/2018-10-I.cpp}


\end{document} 
